import t,{useEffect as e,useState as o}from"react";import n from"zustand/vanilla";import r from"zustand";import s from"humps";import i from"axios";import a from"immer";import{mergeRight as c,uniqBy as l,isNil as u,findIndex as d,propEq as f,mergeDeepRight as m}from"ramda";import*as h from"ably";import A from"mitt";import p from"dayjs";import y from"dayjs/plugin/localizedFormat";import g from"dayjs/plugin/relativeTime";import v from"dayjs/plugin/updateLocale";function w(){return(w=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n])}return t}).apply(this,arguments)}function P(t,e){if(null==t)return{};var o,n,r={},s=Object.keys(t);for(n=0;n<s.length;n++)e.indexOf(o=s[n])>=0||(r[o]=t[o]);return r}const S=n(()=>({apiKey:"",apiSecret:void 0,userEmail:void 0,userExternalId:void 0,userKey:void 0,clientId:Math.random().toString(36).substring(2)+Date.now(),serverURL:"https://api.magicbell.com"})),k="__MAGICBELL_HOOKS__",U="undefined"==typeof window?global:window,O={get:(t,e)=>U[k]&&U[k][t]?U[k][t]:e,set(t,e){U[k]=U[k]||{},U[k][t]=e}};function x(){const{apiKey:t,apiSecret:e,clientId:o,userEmail:n,userExternalId:r,userKey:s}=S.getState(),i={"X-MAGICBELL-CLIENT-ID":o,"X-MAGICBELL-API-KEY":t};return e&&(i["X-MAGICBELL-API-SECRET"]=e),n&&(i["X-MAGICBELL-USER-EMAIL"]=n),s&&(i["X-MAGICBELL-USER-HMAC"]=s),r&&(i["X-MAGICBELL-USER-EXTERNAL-ID"]=r),i}function E(t,e,o,n){const{serverURL:r}=S.getState(),s=x();return O.get("axios",i)({method:t,url:e,data:o,params:n,headers:s,baseURL:r}).then(t=>t.data,t=>{throw t})}function R(t,e={}){return E("get",t,void 0,e)}function C(t,e={},o={}){return E("post",t,e,o)}function L(t,e={}){return E("delete",t,void 0,e)}function M(t,e,o={}){return E("put",t,e,o)}class b{constructor(t="/config"){this.remotePathOrUrl=void 0,this.remotePathOrUrl=t}async get(){const t=await R(this.remotePathOrUrl);return s.camelizeKeys(t)}}const _=r((t,e)=>({channels:void 0,inbox:void 0,ws:void 0,lastFetchedAt:void 0,_repository:new b,fetch:async()=>{const{_repository:o}=e(),n=await o.get();t(w({},n,{lastFetchedAt:Date.now()}))}}));class I extends class{constructor(t){this.remotePathOrUrl=void 0,this.remotePathOrUrl=t}async get(t){const e=`${this.remotePathOrUrl}/${t}`,o=await R(e);return s.camelizeKeys(o)}async findBy(t){try{const e=await R(this.remotePathOrUrl,t);return s.camelizeKeys(e)}catch(t){if(/Network Error/.test(t.message))return;throw t}}delete(t){return L(`${this.remotePathOrUrl}/${t}`).then(()=>!0).catch(()=>!1)}}{constructor(t="/notifications"){super(t)}markAsRead(t){return C(`${this.remotePathOrUrl}/${t}/read`).then(()=>!0).catch(()=>!1)}markAsUnread(t){return C(`${this.remotePathOrUrl}/${t}/unread`).then(()=>!0).catch(()=>!1)}markAllAsSeen(){return C(`${this.remotePathOrUrl}/seen`).then(()=>!0).catch(()=>!1)}markAllAsRead(){return C(`${this.remotePathOrUrl}/read`).then(()=>!0).catch(()=>!1)}}const N=A(),D=A();function $(t,e,o){"remote"===o&&N.emit(t,e),D.emit(t,{data:e,source:o})}function F(t){const{clientId:e}=S.getState(),o=t.name.replace(/\//gi,"."),n=t.data;return n.client_id&&n.client_id===e?Promise.resolve(!1):"string"==typeof n.id?"notifications.delete"===o?($(o,n,"remote"),Promise.resolve(!0)):(new I).get(n.id).then(t=>($(o,t.notification,"remote"),!0)):($(o,n,"remote"),Promise.resolve(!0))}function K(t){return c({context:{},total:0,totalPages:0,perPage:0,currentPage:1,unreadCount:0,unseenCount:0,notifications:[]},t)}const j=["notifications"];function z(t,e){return t===e||t!=t&&e!=e}function B(t,e,o=z){const n=[];return Object.keys(e).forEach(r=>{const s=e[r];var i;("read"===r&&!o(!u(t.readAt),s)||"seen"===r&&!o(!u(t.seenAt),s)||"categories"===r&&(i=s,Array.isArray(i)?i:[i]).some(e=>!o(t.category,e))||Object.hasOwnProperty.call(t,r)&&!o(t[r],s))&&n.push(r)}),{result:0===n.length,delta:n}}const G=r((t,e)=>({stores:{},_repository:new I,setStore:(e,o={},n={})=>{t(a(t=>{t.stores[e]=K(w({},n,{context:o}))}))},fetchStore:async(o,n={},r={})=>{const{stores:s,_repository:i}=e(),c=s[o];if(c){const e=await i.findBy(w({},c.context,n));if(!e)return;t(a(t=>{t.stores[o]=function(t,e,o={reset:!1}){const{notifications:n}=e,r=P(e,j),s=o.reset?n:l(t=>t.id,o.prepend?[...n,...t.notifications]:[...t.notifications,...n]);return w({context:t.context,notifications:s},r)}(c,w({},e,{lastFetchedAt:new Date}),r)}))}else console.error(`Store not found. Define a store with the ${o} ID`)},fetchAllStores:async(t={},o={})=>{const{stores:n,fetchStore:r}=e(),s=Object.keys(n).map(e=>r(e,t,o));await Promise.all(s)},markNotificationAsSeen:o=>{const{stores:n}=e(),r=o.id;$("notifications.seen",o,"local"),t(a(t=>{for(const e in n){const{notifications:o,unseenCount:s}=n[e],i=d(f("id",r),o);i>-1&&(o[i].seenAt||(t.stores[e].unseenCount=Math.max(0,s-1),t.stores[e].notifications[i]=c(o[i],{seenAt:Date.now()/1e3})))}}))},markNotificationAsRead:o=>{const{stores:n,_repository:r}=e(),{id:s}=o,i=r.markAsRead(s);return $("notifications.read",o,"local"),t(a(t=>{const e={readAt:Date.now()/1e3};for(const r in n){const{total:i,notifications:a,unreadCount:l,context:u}=n[r],m=d(f("id",s),a);if(m>-1){t.stores[r].unreadCount=Math.max(0,l-1);const o=c(a[m],e);B(o,u).result?t.stores[r].notifications[m]=o:(t.stores[r].total=Math.max(0,i-1),t.stores[r].notifications.splice(m,1))}else{const n=c(o,e);B(n,u).result&&(t.stores[r].total+=1,t.stores[r].notifications.push(n))}}})),i},markNotificationAsUnread:o=>{const{stores:n,_repository:r}=e(),{id:s}=o,i=r.markAsUnread(s);return $("notifications.unread",o,"local"),t(a(t=>{const e={readAt:null};for(const r in n){const{total:i,notifications:a,context:l}=n[r],u=d(f("id",s),a);if(u>-1){const o=c(a[u],e);B(o,l).result?(t.stores[r].unreadCount+=1,t.stores[r].notifications[u]=o):(t.stores[r].total-=Math.max(0,i-1),t.stores[r].notifications.splice(u,1))}else{const n=c(o,e);B(n,l).result&&(t.stores[r].total+=1,t.stores[r].unreadCount+=1,t.stores[r].notifications.push(n))}}})),i},deleteNotification:(o,n={})=>{const{stores:r,_repository:s}=e(),i=o.id;let c=Promise.resolve(!0);return!1!==n.persist&&(c=s.delete(i),$("notifications.delete",o,"local")),t(a(t=>{for(const e in r){const{notifications:o,total:n,unseenCount:s,unreadCount:a}=r[e],c=d(f("id",i),o);if(c>-1){const r=o[c];r.seenAt||(t.stores[e].unseenCount=Math.max(0,s-1)),r.readAt||(t.stores[e].unreadCount=Math.max(0,a-1)),t.stores[e].total=Math.max(0,n-1),t.stores[e].notifications.splice(c,1)}}})),c},markAllAsSeen:(o={persist:!0,updateModels:!0})=>{const{stores:n,_repository:r}=e();let s=Promise.resolve(!0);return!1!==o.persist&&(s=r.markAllAsSeen(),$("notifications.seen.all",null,"local")),t(a(t=>{for(const e in n){const{notifications:r}=n[e];t.stores[e].unseenCount=0,!1!==o.updateModels&&r.forEach((o,n)=>{t.stores[e].notifications[n]=c(o,{seenAt:Date.now()/1e3})})}})),s},markAllAsRead:(o={persist:!0,updateModels:!0})=>{const{stores:n,_repository:r}=e();let s=Promise.resolve(!0);return!1!==o.persist&&(s=r.markAllAsRead(),$("notifications.read.all",null,"local")),t(a(t=>{for(const e in n){const{notifications:r}=n[e];t.stores[e].unreadCount=0,!1!==o.updateModels&&r.forEach((o,n)=>{t.stores[e].notifications[n]=c(o,{readAt:Date.now()/1e3})})}})),s}}));function X(t,o,n={source:"any"}){e(()=>{const e=(t={})=>{"remote"===n.source&&"remote"!==t.source||"local"===n.source&&"local"!==t.source||o(t.data,t.source)};return D.on(t,e),()=>{D.off(t,e)}},[])}function T(){const t=G(),o=()=>t.fetchAllStores({page:1},{reset:!0});return function(){const t=_();e(()=>t.ws?function(t){const{channel:e}=t,o=function(t){const{serverURL:e}=S.getState(),o=`${e}/${t.authUrl}`,n=x();return new h.Realtime({authUrl:o,authHeaders:n,authMethod:"POST",log:{level:0},transports:["web_socket"]})}(t),n=()=>$("wakeup",null,"local");o.connection.on("disconnected",n),o.connection.on("suspended",n);const r=o.channels.get(e);return r.subscribe(F),()=>{r.unsubscribe(F),r.detach(),o.connection.off("disconnected"),o.connection.off("suspended"),o.close()}}(t.ws):()=>{},[t.ws])}(),X("wakeup",o),X("notifications.new",()=>t.fetchAllStores({page:1},{prepend:!0}),{source:"remote"}),X("notifications.seen.all",()=>t.markAllAsSeen({persist:!1}),{source:"remote"}),X("notifications.read.all",()=>t.markAllAsRead({persist:!1}),{source:"remote"}),X("notifications.read",o,{source:"remote"}),X("notifications.unread",o,{source:"remote"}),X("notifications.delete",e=>t.deleteNotification(e,{persist:!1}),{source:"remote"}),null}const H=["serverURL"],J=["children","stores","disableRealtime"];function Q(t){let{serverURL:e}=t;const o=P(t,H);return e&&(o.serverURL=e),S.setState(o),o}function Y(n){let{children:r,stores:s=[{id:"default",defaultQueryParams:{}}],disableRealtime:i}=n,a=P(n,J);o(()=>Q(a)),o(()=>function(t){const e={};return t.forEach(t=>{const{defaultQueryParams:o,defaults:n={}}=t;e[t.id]=K(w({context:o},n))}),G.setState({stores:e}),e}(s));const c=_();return e(()=>{c.lastFetchedAt||c.fetch()},[c]),t.createElement(t.Fragment,null,i?null:t.createElement(T,null),r)}function q(t="default"){const{stores:o,fetchStore:n,markAllAsSeen:r,markAllAsRead:s}=G(),i=_(),a=o[t],c=(e,o)=>n(t,e,o);return e(()=>{a&&i.lastFetchedAt&&!a.lastFetchedAt&&c({page:1})},[i.lastFetchedAt]),a?w({},a,{isEmpty:0===a.notifications.length,hasNextPage:a.currentPage<a.totalPages,fetch:c,fetchNextPage:(e={},o)=>n(t,w({},e,{page:a.currentPage+1}),o),markAllAsSeen:r,markAllAsRead:s}):null}function V({storeId:t}={}){const e=q(t);return e?w({},e,{markAllAsSeen:()=>e&&e.unseenCount>0?null==e?void 0:e.markAllAsSeen({updateModels:!1}):Promise.resolve(!0)}):null}function W(t){return t?Z(1e3*t):null}function Z(t){return p(t)}function tt(t){return p(t).unix()}function et(t){if(u(t))return null;if("string"==typeof t)try{return JSON.parse(t)}catch(t){console.warn('"customAttributes" is not valid JSON')}return t}function ot(t){const{markNotificationAsRead:e,markNotificationAsSeen:o,markNotificationAsUnread:n,deleteNotification:r}=G();return w({},t,{customAttributes:et(t.customAttributes),readAt:W(t.readAt),seenAt:W(t.seenAt),sentAt:W(t.sentAt),archivedAt:W(t.archivedAt),isSeen:!u(t.seenAt),isRead:!u(t.readAt),isArchived:!u(t.archivedAt),sanitizedContent:t.content,markAsSeen:()=>o(t),markAsRead:()=>e(t),markAsUnread:()=>n(t),delete:()=>r(t)})}function nt(t,o){e(()=>()=>{o?o(t):t.markAsSeen()},[])}function rt(t,e){const o=ot(t);return nt(o,e),o}p.extend(y),p.extend(g),p.extend(v);class st{constructor(t="/notification_preferences"){this.remotePathOrUrl=void 0,this.remotePathOrUrl=t}async get(){const t=await R(this.remotePathOrUrl);return s.camelizeKeys(t)}update(t){return M(this.remotePathOrUrl,s.decamelizeKeys(t)).then(()=>!0).catch(()=>!1)}}const it=r((t,e)=>({categories:{},_repository:new st,fetch:async()=>{const{_repository:o}=e(),{notificationPreferences:n}=await o.get();t(w({},n,{lastFetchedAt:Date.now()}))},save:async o=>{const{_repository:n,categories:r}=e();n.update({notificationPreferences:o}),t({categories:m(r,o.categories),lastFetchedAt:Date.now()})}}));export{Y as MagicBellProvider,T as RealtimeListener,K as buildStore,S as clientSettings,L as deleteAPI,D as eventAggregator,R as fetchAPI,C as postAPI,N as pushEventAggregator,M as putAPI,O as registry,W as secondsToDate,Z as toDate,tt as toUnix,V as useBell,_ as useConfig,X as useMagicBellEvent,rt as useNotification,ot as useNotificationFactory,it as useNotificationPreferences,G as useNotificationStoresCollection,nt as useNotificationUnmount,q as useNotifications};
//# sourceMappingURL=magicbell-react-headless.modern.js.map
